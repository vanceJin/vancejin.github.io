<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
###本章内容
委托   
类型系统的特征   
值/引用类型   

##2.1 委托
委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口；   
 委托类型声明中所描述的类型签名决定了哪个方法可用于创建委托实例，同时决定了调用的签名；   
 为了创建委托实例，需要一个方法以及（对于实例方法来说）调用方法的目标；   
 委托实例是不易变的；   
 每个委托实例都包含一个调用列表——一个操作列表；   
 委托实例可以合并到一起，也可以从一个委托实例中删除另一个；   
 事件不是委托实例——只是成对的add/remove方法（类似于属性的取值方法/赋值方法）。   

##2.2 类型系统的特征
###2.2.1 C#在类型系统世界中的位置
C# 1的类型系统是静态的、显式的和安全的。

C#是静态类型的：每个变量都有一个特定的类型，而且该类型在编译时是已知的①。只有该类型已知的操作才是允许的，这一点由编译器强制生效。

对于显式类型来说，每个变量的类型都必须在声明中显式指明。

###2.2.2 C# 1 的类型系统何时不够用
在两种常见的情况下，你可能想向方法的调用者揭示更多的信息，或者想强迫调用者对它们在参数值中提供的内容进行限制。第一种情况涉及集合，第二种情况涉及继承和覆盖方法或实现接口。

###2.2.3 类型系统特征总结
本节描述了不同类型系统的一些差异，并具体描述了C# 1的特征：   
. C# 1是静态类型的——编译器知道你能使用哪些成员；   
. C# 1是显式的——必须告诉编译器变量具有什么类型；   
. C# 1是安全的——除非存在真实的转换关系，否则不能将一种类型当做另一种类型；   
. 静态类型仍然不允许一个集合成为强类型的“字符串列表”或者“整数列表”，除非针对
不同的元素使用大量的重复代码；   
. 方法覆盖和接口实现不允许协变性/逆变性。   

##2.3 值类型和引用类型
.NET中的大多数类型都是引用类型，你以后创建的引用类型极有可能比值类型多很多。除了以下总结的特殊情况，类（使用class来声明）是引用类型，而结构（使用struct来声明）是值类型。特殊情况包括如下方面：    
 数组类型是引用类型，即使元素类型是值类型（所以即便int是值类型，int[]仍是引用类型）；   
 枚举（使用enum来声明）是值类型；   
 委托类型（使用delegate来声明）是引用类型；   
 接口类型（使用interface来声明）是引用类型，但可由值类型实现。   

对于值类型的表达式，它的值就是表达式的值。然而，对于引用类型的表达式，它
的值是一个引用，而不是该引用所指代的对象。   
变量的值在它声明时的位置存储。局部变量的值总是存储在栈（stack）中①，实例变量的值总是存储在实例本身存储的地方。引用类型实例（对象）总是存储在堆（heap）中，静态变量也是。   
两种类型的另一个差异在于，值类型不可以派生出其他类型。这将导致的一个结果就是，值不需要额外的信息来描述值实际是什么类型。把它同引用类型比较，对于引用类型来说，每个对象的开头都包含一个数据块，它标识了对象的实际类型，同时还提供了其他一些信息。永远都不能改变对象的类型——执行简单的强制类型转换时，运行时会获取一个引用，检查它引用的对象是不是目标类型的一个有效对象。如果有效，就返回原始引用；否则抛出异常。引用本身并不知道对象的类型——所以同一个引用“值”可用于（引用）不同类型的多个变量。

###2.3.3 走出误区
误区1：“结构是轻量级的类”   
这个误解存在着多种形式。有人认为值类型不能或不应有方法或其他有意义的行为——它们应作为简单的数据转移类型来使用，只应该有public字段或简单的属性。对于这种说法，一个非常典型的反例就是DateTime类型：它作为值类型来提供是很有道理的，因为它非常适合作为和数字或字符相似的一个基本单位来使用。另外，它也理应被赋予对它的值执行计算的能力。换个角度来看这个问题，是数据转移类型一般都是引用类型。总之，具体应该如何决定，应取决于需要的是值类型的语义，还是引用类型的语义，而不是取决于这个类型简单与否。

误区2：“引用类型保存在堆上，值类型保存在栈上”   
。第一部分是正确的——引用类型的实
例总是在堆上创建的。但第二部分就有问题了。前面讲过，变量的值是在它声明的位置存储的。所以，假定一个类中有一个int类型的实例变量，那么在这个类的任何对象中，该变量的值总是和对象中的其他数据在一起，也就是在堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。对于C# 2及更高版本，很多局部变量并不完全存放在栈中，第5章中的匿名方法会讲到这一点。   

误区3：“对象在C#中默认是通过引用传递的”   

###2.3.4 装箱和拆箱
C#和.NET提供了一个名为装箱（boxing）的机制，它允许根据值类型创建一个对象，然后使用对这个新对象的一个引用。   
 对于引用类型的变量，它的值永远是一个引用；   
 对于值类型的变量，它的值永远是该值类型的一个值。   

之所以要留意装箱和拆箱，是由于它们可能会降低性能。一次装箱或拆箱操作的开销是微不足道的，但假如执行千百次这样的操作，那么不仅会增大程序本身的操作开销，还会创建数量众多的对象，而这些对象会加重垃圾回收器的负担。同样，这种性能损失通常也不是大问题，但还是应该引起注意，因此如果你关心的话，可以对拆装箱带来的影响进行测试。   

2.3.5 值类型和引用类型小结   
本节讨论了值类型和引用类型的差异，还澄清了围绕它们存在的一些误区。下面是一些要点。   
 对于引用类型的表达式（如一个变量），它的值是一个引用，而非对象。   
 引用就像URL——是允许你访问真实信息的一小片数据。   
 对于值类型的表达式，它的值是实际的数据。   
 有时，值类型比引用类型更有效，有时恰好相反。   
 引用类型的对象总是在堆上，值类型的值既可能在栈上，也可能在堆上，具体取决于上下文。   
 引用类型作为方法参数使用时，参数默认是以“值传递”方式来传递的——但值本身是一个引用。   
 值类型的值会在需要引用类型的行为时被装箱；拆箱则是相反的过程。   

##2.4 C# 1 之外：构建于坚实基础之上的新特性
总之，和委托有关的新特性包括：   
 泛型（泛型委托类型）——C# 2；   
 创建委托实例时使用的表达式——C# 2；   
 匿名方法——C# 2；   
 委托协变性/逆变性——C# 2；   
 Lambda表达式——C# 3。   

下面简单看一下这些特性，以及各个特性是在C#的哪个版本中引入的：   
 泛型——C# 2；   
 受限的委托协变性/逆变性——C# 2；   
 匿名类型——C# 3；   
 隐式类型——C# 3；   
 扩展方法——C# 3；   
 受限的泛型协变/逆变——C# 4；   
 动态类型——C# 4。   

###2.4.3 与值类型有关的特性
 泛型——C# 2；   
 可空类型（可以为null的类型）——C# 2。   

##2.5 小结
本章简要讨论的3个核心主题在更高版本的C#中都有了显著增强，而且一些特性涉及多个主题。尤其是泛型，它对本章讨论的几乎所有领域都有影响，它或许是使用最广泛、也是最重要的一个C# 2特性。







<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h3 id="">本章内容</h3>

<p>委托 <br>
类型系统的特征 <br>
值/引用类型   </p>

<h2 id="21">2.1 委托</h2>

<p>委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口； <br>
 委托类型声明中所描述的类型签名决定了哪个方法可用于创建委托实例，同时决定了调用的签名； <br>
 为了创建委托实例，需要一个方法以及（对于实例方法来说）调用方法的目标； <br>
 委托实例是不易变的； <br>
 每个委托实例都包含一个调用列表——一个操作列表； <br>
 委托实例可以合并到一起，也可以从一个委托实例中删除另一个； <br>
 事件不是委托实例——只是成对的add/remove方法（类似于属性的取值方法/赋值方法）。   </p>

<h2 id="22">2.2 类型系统的特征</h2>

<h3 id="221c">2.2.1 C#在类型系统世界中的位置</h3>

<p>C# 1的类型系统是静态的、显式的和安全的。</p>

<p>C#是静态类型的：每个变量都有一个特定的类型，而且该类型在编译时是已知的①。只有该类型已知的操作才是允许的，这一点由编译器强制生效。</p>

<p>对于显式类型来说，每个变量的类型都必须在声明中显式指明。</p>

<h3 id="222c1">2.2.2 C# 1 的类型系统何时不够用</h3>

<p>在两种常见的情况下，你可能想向方法的调用者揭示更多的信息，或者想强迫调用者对它们在参数值中提供的内容进行限制。第一种情况涉及集合，第二种情况涉及继承和覆盖方法或实现接口。</p>

<h3 id="223">2.2.3 类型系统特征总结</h3>

<p>本节描述了不同类型系统的一些差异，并具体描述了C# 1的特征： <br>
. C# 1是静态类型的——编译器知道你能使用哪些成员； <br>
. C# 1是显式的——必须告诉编译器变量具有什么类型； <br>
. C# 1是安全的——除非存在真实的转换关系，否则不能将一种类型当做另一种类型； <br>
. 静态类型仍然不允许一个集合成为强类型的“字符串列表”或者“整数列表”，除非针对
不同的元素使用大量的重复代码； <br>
. 方法覆盖和接口实现不允许协变性/逆变性。   </p>

<h2 id="23">2.3 值类型和引用类型</h2>

<p>.NET中的大多数类型都是引用类型，你以后创建的引用类型极有可能比值类型多很多。除了以下总结的特殊情况，类（使用class来声明）是引用类型，而结构（使用struct来声明）是值类型。特殊情况包括如下方面： <br>
 数组类型是引用类型，即使元素类型是值类型（所以即便int是值类型，int[]仍是引用类型）； <br>
 枚举（使用enum来声明）是值类型； <br>
 委托类型（使用delegate来声明）是引用类型； <br>
 接口类型（使用interface来声明）是引用类型，但可由值类型实现。   </p>

<p>对于值类型的表达式，它的值就是表达式的值。然而，对于引用类型的表达式，它
的值是一个引用，而不是该引用所指代的对象。 <br>
变量的值在它声明时的位置存储。局部变量的值总是存储在栈（stack）中①，实例变量的值总是存储在实例本身存储的地方。引用类型实例（对象）总是存储在堆（heap）中，静态变量也是。 <br>
两种类型的另一个差异在于，值类型不可以派生出其他类型。这将导致的一个结果就是，值不需要额外的信息来描述值实际是什么类型。把它同引用类型比较，对于引用类型来说，每个对象的开头都包含一个数据块，它标识了对象的实际类型，同时还提供了其他一些信息。永远都不能改变对象的类型——执行简单的强制类型转换时，运行时会获取一个引用，检查它引用的对象是不是目标类型的一个有效对象。如果有效，就返回原始引用；否则抛出异常。引用本身并不知道对象的类型——所以同一个引用“值”可用于（引用）不同类型的多个变量。</p>

<h3 id="233">2.3.3 走出误区</h3>

<p>误区1：“结构是轻量级的类” <br>
这个误解存在着多种形式。有人认为值类型不能或不应有方法或其他有意义的行为——它们应作为简单的数据转移类型来使用，只应该有public字段或简单的属性。对于这种说法，一个非常典型的反例就是DateTime类型：它作为值类型来提供是很有道理的，因为它非常适合作为和数字或字符相似的一个基本单位来使用。另外，它也理应被赋予对它的值执行计算的能力。换个角度来看这个问题，是数据转移类型一般都是引用类型。总之，具体应该如何决定，应取决于需要的是值类型的语义，还是引用类型的语义，而不是取决于这个类型简单与否。</p>

<p>误区2：“引用类型保存在堆上，值类型保存在栈上” <br>
。第一部分是正确的——引用类型的实
例总是在堆上创建的。但第二部分就有问题了。前面讲过，变量的值是在它声明的位置存储的。所以，假定一个类中有一个int类型的实例变量，那么在这个类的任何对象中，该变量的值总是和对象中的其他数据在一起，也就是在堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。对于C# 2及更高版本，很多局部变量并不完全存放在栈中，第5章中的匿名方法会讲到这一点。   </p>

<p>误区3：“对象在C#中默认是通过引用传递的”   </p>

<h3 id="234">2.3.4 装箱和拆箱</h3>

<p>C#和.NET提供了一个名为装箱（boxing）的机制，它允许根据值类型创建一个对象，然后使用对这个新对象的一个引用。 <br>
 对于引用类型的变量，它的值永远是一个引用； <br>
 对于值类型的变量，它的值永远是该值类型的一个值。   </p>

<p>之所以要留意装箱和拆箱，是由于它们可能会降低性能。一次装箱或拆箱操作的开销是微不足道的，但假如执行千百次这样的操作，那么不仅会增大程序本身的操作开销，还会创建数量众多的对象，而这些对象会加重垃圾回收器的负担。同样，这种性能损失通常也不是大问题，但还是应该引起注意，因此如果你关心的话，可以对拆装箱带来的影响进行测试。   </p>

<p>2.3.5 值类型和引用类型小结 <br>
本节讨论了值类型和引用类型的差异，还澄清了围绕它们存在的一些误区。下面是一些要点。 <br>
 对于引用类型的表达式（如一个变量），它的值是一个引用，而非对象。 <br>
 引用就像URL——是允许你访问真实信息的一小片数据。 <br>
 对于值类型的表达式，它的值是实际的数据。 <br>
 有时，值类型比引用类型更有效，有时恰好相反。 <br>
 引用类型的对象总是在堆上，值类型的值既可能在栈上，也可能在堆上，具体取决于上下文。 <br>
 引用类型作为方法参数使用时，参数默认是以“值传递”方式来传递的——但值本身是一个引用。 <br>
 值类型的值会在需要引用类型的行为时被装箱；拆箱则是相反的过程。   </p>

<h2 id="24c1">2.4 C# 1 之外：构建于坚实基础之上的新特性</h2>

<p>总之，和委托有关的新特性包括： <br>
 泛型（泛型委托类型）——C# 2； <br>
 创建委托实例时使用的表达式——C# 2； <br>
 匿名方法——C# 2； <br>
 委托协变性/逆变性——C# 2； <br>
 Lambda表达式——C# 3。   </p>

<p>下面简单看一下这些特性，以及各个特性是在C#的哪个版本中引入的： <br>
 泛型——C# 2； <br>
 受限的委托协变性/逆变性——C# 2； <br>
 匿名类型——C# 3； <br>
 隐式类型——C# 3； <br>
 扩展方法——C# 3； <br>
 受限的泛型协变/逆变——C# 4； <br>
 动态类型——C# 4。   </p>

<h3 id="243">2.4.3 与值类型有关的特性</h3>

<p> 泛型——C# 2； <br>
 可空类型（可以为null的类型）——C# 2。   </p>

<h2 id="25">2.5 小结</h2>

<p>本章简要讨论的3个核心主题在更高版本的C#中都有了显著增强，而且一些特性涉及多个主题。尤其是泛型，它对本章讨论的几乎所有领域都有影响，它或许是使用最广泛、也是最重要的一个C# 2特性。</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "2017050702.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
